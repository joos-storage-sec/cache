# cache
Кеширование Redis/memcached

**Кэширование** — это способ оптимизации работы приложения, при котором данные временно кладутся в промежуточный буфер с быстрым доступом. Выбор буфера для кэша зависит от решаемой задачи и может быть как памятью сервера, так и файлом, базой данных или любой другой сущностью, куда можно положить данные. Обычно данные в кэше — это данные, к которым наиболее часто осуществляется запрос

**Важно учесть при работе с кэшом**
- Инвалидация. Если данные изменяемые (например, кэш ответов из базы данных), то их нужно будет инвалидировать при изменении в источнике;
- TTL (time-to-live). Кэш не может жить вечно, и нужно быть готовым к тому, что он «протухнет» или «потеряется в любой момент»;
- Кэшировать данные нужно только при необходимости, так как это усложняет архитектуру и может добавить проблем в эксплуатации.

**Какие проблемы призвано решить кэширование?**
- Повышение производительности достигается за счет складывания в кэш данных, к которым чаще всего происходит обращение;
- Увеличение скорости ответа;
- Экономия ресурсов базы данных, например, применяя кэширование тяжелых запросов;
- Сглаживание бустов трафика. Например, во время черной пятницы онлайн-магазины используют кэш, чтобы переживать резкое увеличение трафика.

Понятие кэширования очень растяжимое:
- DNS;
- CDN;
- HTTP-кэширование;
- Кэш процессора;
- Тяжелые запросы в базу данных.

**Алгоритмы кэширования**

Самая оптимальная стратегия кэширования — это подход, при котором мы кэшируем только то, что будем использовать в будущем и убираем из кэша то, что использовать не будем. Однако, чтобы добиться этого, нужно уметь предсказывать будущее.

**LRU (least recently used)** - LRU (вытеснение давно неиспользуемых) — это алгоритм, при котором вытесняются значения, которые дольше всего не запрашивались. Соответственно, необходимо хранить время последнего запроса к значению. И как только число закэшированных значений превосходит N, необходимо вытеснить из кеша значение, которое дольше всего не запрашивалось.

**PLRU (pseudo least recently used)** - PLRU (псевдо-LRU) алгоритм призван улучшить производительность LRU для кэша с большой ассоциативностью. При помощи двоичного дерева для поиска алгоритм эффективно понимает, где самый молодой элемент кэша, а где самый старый. Может быть неоптимальным и неверно вытеснять записи.

**LFU (Least-Frequently Used)** - LFU (наименее часто используемый) — из кэша вытесняются элементы, которые реже всего используются. Для этого у каждого элемента в кэше ведется счетчик обращения к нему. В таком виде алгоритм может давать сбои и вытеснять только что добавленные элементы, к которым еще ни разу не было повторного обращения. Редко можно встретить реальное использование.

**Memcached**

Бесплатная высокопроизводительная система кэширования с открытым исходным кодом. Универсальная по своей природе, но предназначенная для ускорения работы динамических веб- приложений за счет снижения нагрузки на базу данных. **Memcached** — это in-memory хранилище значений ключей для небольших фрагментов произвольных данных (строк, объектов) из результатов вызовов баз данных, API или рендеринга страниц.
- Был написан в LiveJournal Брэдом Фицпатриком и выпущен в OSS в 2003 году. С тех пор оброс большим комьюнити.
- Является простым и популярным решением для in-memory кэширования даже в наши дни.
- Из коробки умеет шардировать ключи с помощью клиентской библиотеки.
- Работает на порту 11211.
- Работает с кэшом по алгоритму LRU с TTL.
База сохраняет свою простоту, но:
- Нет неймспейсов. Чтобы отделить ключи одного приложения от другого, нужно либо использовать некрасивые префиксы, либо запускать отдельный инстанс memcached;
- Нельзя флашнуть сабсет ключей. Из-за того что ключи никак не сгруппированы, нельзя удалить часть и нельзя запросить часть для удаления;
- In-memory. Рестарт базы удалит все данные;
- Нет репликации из коробки;
- Нет типизации. Все данные — это строки.
**Установка memcached на сервер с Debian 10 с помощью apt:**
```
$ sudo apt update && apt install memcached
```
Убеждаемся, что база запустилась:
```
$ systemctl status memcached
● memcached.service - memcached daemon
Loaded: loaded (/lib/systemd/system/memcached.service; enabled; vendor preset: enabled)
Active: active (running) since Sun 2021-08-15 21:10:46 UTC; 1s ago
Docs: man:memcached(1)
Main PID: 1591 (memcached)
```
Если клиентом memcached будет не localhost, то переопределяем IP-
адрес, который слушает база в конфиге /etc/memcached.conf:
```
# Specify which IP address to listen on. The default is to listen on all IP
addresses
# This parameter is one of the only security measures that memcached has, so
make sure
# it's listening on a firewalled interface.
-l 127.0.0.1
```
Memcached сам по себе считается хранилищем с бесконечным горизонтальным масштабированием. Однако, оно не отказоустойчивое и для него в редких случаях требуется добавление репликации между нодами. Эту задачу решает mcrouter. Он выступает проксей между клиентом и нодами memcached, предоставляя возможности репликации данных.

**Redis**

**Redis (remote dictionary server)** — это in-memory хранилище структур данных с открытым исходным кодом, используемое в качестве базы данных, кэша и очереди сообщений.

Отличительные характеристики:
- Есть неймспейсы. На старте базы их 16, но это значение меняется в конфиге;
- In-memory. Но данные персистентно хранятся на диске;
- Репликация из коробки;
- Типизация. Есть поддержка разных типов данных;
- Lua-скриптинг. Позволяет писать свои хранимые процедуры;
- Транзакции.
Политики вытеснения работают только тогда, когда у redis закончилось место в памяти:
- noeviction: возвращает ошибки, когда достигнут предел памяти и клиент пытается выполнить команды, которые могут привести к увеличению объема используемой памяти;
- allkeys-lru: ключи удаляются по алгоритму LRU;
- volatile-lru: удаляются только ключи с истекшим TTL;
- allkeys-random: случайное удаление ключей;
- allkeys-random: случайное удаление ключей;
- volatile-random: случайное удаление ключей с истекшим TTL;
- volatile-ttl: удаление ключей с истекшим TTL и с наиболее коротким TTL;
- volatile-lfu: удаляются ключи с истекшим TTL по LFU;
- allkeys-lfu: все ключи удаляются по LFU
**Установка redis на сервер с Debian 10 с помощью apt:**
```
$ sudo apt update && apt install redis
```
Убеждаемся, что база запустилась:
```
$ systemctl status redis
● redis-server.service - Advanced key-value store
Loaded: loaded (/lib/systemd/system/redis-server.service; enabled; vendor
preset: enabled)
Active: active (running) since Tue 2021-08-17 06:22:23 UTC; 24min ago
```
Идем в redis-cli после установки:
```
# redis-cli
127.0.0.1:6379> INFO
# Server
redis_version:5.0.3
```
**Redis Cluster**

Cluster был добавлен в Redis v.2.4, и является сервисом мониторинга состояния мастер и слейв нод. Умеет отправлять уведомления о событиях, выполнять переключение между мастером и слейвом, если мастер вышел из строя.

Важные особенности cluster
- Для минимального запуска требуется 6 нод: 3 master и 3 slave;
- Несколько master-нод, у каждой может быть до 1000 слейвов;
- Поддерживает шардинг, репликацию, переключение мастера и синхронизацию данных.
**Redis Sentinel**

Sentinel был добавлен в Redis v.2.4, и является сервисом мониторинга состояния мастер и слейв нод.

Важные особенности sentinel
- Может работать как отдельный демон или как redis в режиме sentinel;
- В случае выхода из строя мастера, переключает его на один из слейвов;
- Для работы требуется минимум 3 ноды, чтобы собирать кворум на переключение мастера;
- Configuration provider. Клиенты подключаются к sentinel, чтобы узнать, кто сейчас мастер в кластере.

**Redis vs Memcached** - Memcached имеет смысл использовать только, когда нужна максимальная простота и у вас мало серверов, мало запросов и они точно не будут расти. Но даже в этом случае с задачей лучше справится redis.
